//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by gen. DO NOT EDIT.

package rpc

import (
	context "context"
	iter "iter"
)

// AdminCaller implements Admin via a Caller.
type AdminCaller struct {
	Caller
}

type GetpidRes struct {
	Res0 int
}

func (s *AdminCaller) Getpid() (res0 int, err error) {
	var res_ GetpidRes
	err = s.Caller.Call(context.Background(), "Getpid", nil, &res_)
	return res_.Res0, err
}

type HostnameRes struct {
	Res0 string
}

func (s *AdminCaller) Hostname() (res0 string, err error) {
	var res_ HostnameRes
	err = s.Caller.Call(context.Background(), "Hostname", nil, &res_)
	return res_.Res0, err
}

// AdminHandler implements Handler via a Admin.
type AdminHandler struct {
	Admin
}

func (h *AdminHandler) Getpid(ctx context.Context, stream Stream) error {
	var res GetpidRes
	var err_ error
	res.Res0, err_ = h.Admin.Getpid()
	if err_ != nil {
		return err_
	}
	if err := stream.Send(ctx, &res); err != nil {
		return err
	}
	return nil
}

func (h *AdminHandler) Hostname(ctx context.Context, stream Stream) error {
	var res HostnameRes
	var err_ error
	res.Res0, err_ = h.Admin.Hostname()
	if err_ != nil {
		return err_
	}
	if err := stream.Send(ctx, &res); err != nil {
		return err
	}
	return nil
}

func (h *AdminHandler) Methods() iter.Seq2[string, MethodFunc] {
	return func(yield func(string, MethodFunc) bool) {
		if !yield("Getpid", h.Getpid) {
			return
		}
		if !yield("Hostname", h.Hostname) {
			return
		}
	}
}

func (h *AdminHandler) Serve(ctx context.Context, method string, stream Stream) error {
	switch method {
	case "Getpid":
		return h.Getpid(ctx, stream)
	case "Hostname":
		return h.Hostname(ctx, stream)
	default:
		return UnknownMethod(method)
	}
}

// DiscoveryCaller implements Discovery via a Caller.
type DiscoveryCaller struct {
	Caller
}

type ListArg struct {
	Node   string
	Target string
}

type ListRes struct {
	Res0 []string
}

func (s *DiscoveryCaller) List(node string, target string) (res0 []string) {
	arg_ := &ListArg{
		Node:   node,
		Target: target,
	}
	var res_ ListRes
	err := s.Caller.Call(context.Background(), "List", arg_, &res_)
	if err != nil {
		panic(err)
	}
	return res_.Res0
}

// DiscoveryHandler implements Handler via a Discovery.
type DiscoveryHandler struct {
	Discovery
}

func (h *DiscoveryHandler) List(ctx context.Context, stream Stream) error {
	var arg ListArg
	if err := stream.Recv(ctx, &arg); err != nil {
		return err
	}
	var res ListRes
	res.Res0 = h.Discovery.List(arg.Node, arg.Target)
	if err := stream.Send(ctx, &res); err != nil {
		return err
	}
	return nil
}

func (h *DiscoveryHandler) Methods() iter.Seq2[string, MethodFunc] {
	return func(yield func(string, MethodFunc) bool) {
		if !yield("List", h.List) {
			return
		}
	}
}

func (h *DiscoveryHandler) Serve(ctx context.Context, method string, stream Stream) error {
	switch method {
	case "List":
		return h.List(ctx, stream)
	default:
		return UnknownMethod(method)
	}
}
