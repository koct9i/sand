//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by gen. DO NOT EDIT.

package test

import (
	context "context"

	rpc "github.com/koct9i/sand/rpc"
)

// TestCaller implements Test via a Caller.
type TestCaller struct {
	rpc.Caller
}

func (s *TestCaller) WithContext(ctx context.Context) {
	err := s.Caller.Call(ctx, "WithContext", nil, nil)
	if err != nil {
		panic(err)
	}
}

func (s *TestCaller) WithError() (err error) {
	return s.Caller.Call(context.Background(), "WithError", nil, nil)
}

type WithNamesArg struct {
	Param_ int
}

type WithNamesRes struct {
	Result_ int
}

func (s *TestCaller) WithNames(ctx_ context.Context, param_ int) (result_ int, err_ error) {
	arg := &WithNamesArg{
		Param_: param_,
	}
	var res WithNamesRes
	err_ = s.Caller.Call(ctx_, "WithNames", arg, &res)
	return res.Result_, err_
}

func (s *TestCaller) WithNothing() {
	err := s.Caller.Call(context.Background(), "WithNothing", nil, nil)
	if err != nil {
		panic(err)
	}
}

type WithParamArg struct {
	Arg int
}

func (s *TestCaller) WithParam(arg int) {
	arg := &WithParamArg{
		Arg: arg,
	}
	err := s.Caller.Call(context.Background(), "WithParam", arg, nil)
	if err != nil {
		panic(err)
	}
}

type WithResultRes struct {
	Res0 int
}

func (s *TestCaller) WithResult() (res0 int) {
	var res WithResultRes
	err := s.Caller.Call(context.Background(), "WithResult", nil, &res)
	if err != nil {
		panic(err)
	}
	return res.Res0
}

type WithStructParamArg struct {
	Arg Struct
}

func (s *TestCaller) WithStructParam(arg Struct) {
	arg := &WithStructParamArg{
		Arg: arg,
	}
	err := s.Caller.Call(context.Background(), "WithStructParam", arg, nil)
	if err != nil {
		panic(err)
	}
}

type WithStructResultRes struct {
	Res0 Struct
}

func (s *TestCaller) WithStructResult() (res0 Struct) {
	var res WithStructResultRes
	err := s.Caller.Call(context.Background(), "WithStructResult", nil, &res)
	if err != nil {
		panic(err)
	}
	return res.Res0
}

type WithVariadicArg struct {
	Args []int
}

func (s *TestCaller) WithVariadic(args ...int) {
	arg := &WithVariadicArg{
		Args: args,
	}
	err := s.Caller.Call(context.Background(), "WithVariadic", arg, nil)
	if err != nil {
		panic(err)
	}
}

// TestHandler implements Handler via a Test.
type TestHandler struct {
	Test
}

func (h *TestHandler) Serve(ctx context.Context, method string, stream rpc.Stream) error {
	switch method {
	case "WithContext":
		h.WithContext(ctx)
	case "WithError":
		var err error
		err = h.WithError()
		if err != nil {
			return err
		}
	case "WithNames":
		var arg WithNamesArg
		if err := stream.Recv(ctx, &arg); err != nil {
			return err
		}
		var res WithNamesRes
		var err error
		res.Result_, err = h.WithNames(ctx, arg.Param_)
		if err != nil {
			return err
		}
		if err := stream.Send(ctx, &res); err != nil {
			return err
		}
	case "WithNothing":
		h.WithNothing()
	case "WithParam":
		var arg WithParamArg
		if err := stream.Recv(ctx, &arg); err != nil {
			return err
		}
		h.WithParam(arg.Arg)
	case "WithResult":
		var res WithResultRes
		res.Res0 = h.WithResult()
		if err := stream.Send(ctx, &res); err != nil {
			return err
		}
	case "WithStructParam":
		var arg WithStructParamArg
		if err := stream.Recv(ctx, &arg); err != nil {
			return err
		}
		h.WithStructParam(arg.Arg)
	case "WithStructResult":
		var res WithStructResultRes
		res.Res0 = h.WithStructResult()
		if err := stream.Send(ctx, &res); err != nil {
			return err
		}
	case "WithVariadic":
		var arg WithVariadicArg
		if err := stream.Recv(ctx, &arg); err != nil {
			return err
		}
		h.WithVariadic(arg.Args...)
	default:
		return rpc.UnknownMethod(method)
	}
	return nil
}
