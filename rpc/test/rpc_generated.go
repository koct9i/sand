//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by gen. DO NOT EDIT.

package test

import (
	context "context"
	iter "iter"

	rpc "github.com/koct9i/sand/rpc"
)

// TestCaller implements Test via a Caller.
type TestCaller struct {
	rpc.Caller
}

func (s *TestCaller) WithContext(ctx context.Context) {
	err := s.Caller.Call(ctx, "WithContext", nil, nil)
	if err != nil {
		panic(err)
	}
}

func (s *TestCaller) WithError() (err error) {
	return s.Caller.Call(context.Background(), "WithError", nil, nil)
}

type WithNamesArg struct {
	Param_ int
}

type WithNamesRes struct {
	Result_ int
}

func (s *TestCaller) WithNames(ctx_ context.Context, param_ int) (result_ int, err_ error) {
	arg_ := &WithNamesArg{
		Param_: param_,
	}
	var res_ WithNamesRes
	err_ = s.Caller.Call(ctx_, "WithNames", arg_, &res_)
	return res_.Result_, err_
}

func (s *TestCaller) WithNothing() {
	err := s.Caller.Call(context.Background(), "WithNothing", nil, nil)
	if err != nil {
		panic(err)
	}
}

type WithParamArg struct {
	Arg int
}

func (s *TestCaller) WithParam(arg int) {
	arg_ := &WithParamArg{
		Arg: arg,
	}
	err := s.Caller.Call(context.Background(), "WithParam", arg_, nil)
	if err != nil {
		panic(err)
	}
}

type WithResultRes struct {
	Res0 int
}

func (s *TestCaller) WithResult() (res0 int) {
	var res_ WithResultRes
	err := s.Caller.Call(context.Background(), "WithResult", nil, &res_)
	if err != nil {
		panic(err)
	}
	return res_.Res0
}

type WithStructParamArg struct {
	Arg Struct
}

func (s *TestCaller) WithStructParam(arg Struct) {
	arg_ := &WithStructParamArg{
		Arg: arg,
	}
	err := s.Caller.Call(context.Background(), "WithStructParam", arg_, nil)
	if err != nil {
		panic(err)
	}
}

type WithStructResultRes struct {
	Res0 Struct
}

func (s *TestCaller) WithStructResult() (res0 Struct) {
	var res_ WithStructResultRes
	err := s.Caller.Call(context.Background(), "WithStructResult", nil, &res_)
	if err != nil {
		panic(err)
	}
	return res_.Res0
}

type WithVariadicArg struct {
	Args []int
}

func (s *TestCaller) WithVariadic(args ...int) {
	arg_ := &WithVariadicArg{
		Args: args,
	}
	err := s.Caller.Call(context.Background(), "WithVariadic", arg_, nil)
	if err != nil {
		panic(err)
	}
}

// TestHandler implements Handler via a Test.
type TestHandler struct {
	Test
}

func (h *TestHandler) WithContext(ctx context.Context, stream rpc.Stream) error {
	h.Test.WithContext(ctx)
	return nil
}

func (h *TestHandler) WithError(ctx context.Context, stream rpc.Stream) error {
	var err_ error
	err_ = h.Test.WithError()
	if err_ != nil {
		return err_
	}
	return nil
}

func (h *TestHandler) WithNames(ctx context.Context, stream rpc.Stream) error {
	var arg WithNamesArg
	if err := stream.Recv(ctx, &arg); err != nil {
		return err
	}
	var res WithNamesRes
	var err_ error
	res.Result_, err_ = h.Test.WithNames(ctx, arg.Param_)
	if err_ != nil {
		return err_
	}
	if err := stream.Send(ctx, &res); err != nil {
		return err
	}
	return nil
}

func (h *TestHandler) WithNothing(ctx context.Context, stream rpc.Stream) error {
	h.Test.WithNothing()
	return nil
}

func (h *TestHandler) WithParam(ctx context.Context, stream rpc.Stream) error {
	var arg WithParamArg
	if err := stream.Recv(ctx, &arg); err != nil {
		return err
	}
	h.Test.WithParam(arg.Arg)
	return nil
}

func (h *TestHandler) WithResult(ctx context.Context, stream rpc.Stream) error {
	var res WithResultRes
	res.Res0 = h.Test.WithResult()
	if err := stream.Send(ctx, &res); err != nil {
		return err
	}
	return nil
}

func (h *TestHandler) WithStructParam(ctx context.Context, stream rpc.Stream) error {
	var arg WithStructParamArg
	if err := stream.Recv(ctx, &arg); err != nil {
		return err
	}
	h.Test.WithStructParam(arg.Arg)
	return nil
}

func (h *TestHandler) WithStructResult(ctx context.Context, stream rpc.Stream) error {
	var res WithStructResultRes
	res.Res0 = h.Test.WithStructResult()
	if err := stream.Send(ctx, &res); err != nil {
		return err
	}
	return nil
}

func (h *TestHandler) WithVariadic(ctx context.Context, stream rpc.Stream) error {
	var arg WithVariadicArg
	if err := stream.Recv(ctx, &arg); err != nil {
		return err
	}
	h.Test.WithVariadic(arg.Args...)
	return nil
}

func (h *TestHandler) Methods() iter.Seq2[string, rpc.MethodFunc] {
	return func(yield func(string, rpc.MethodFunc) bool) {
		if !yield("WithContext", h.WithContext) {
			return
		}
		if !yield("WithError", h.WithError) {
			return
		}
		if !yield("WithNames", h.WithNames) {
			return
		}
		if !yield("WithNothing", h.WithNothing) {
			return
		}
		if !yield("WithParam", h.WithParam) {
			return
		}
		if !yield("WithResult", h.WithResult) {
			return
		}
		if !yield("WithStructParam", h.WithStructParam) {
			return
		}
		if !yield("WithStructResult", h.WithStructResult) {
			return
		}
		if !yield("WithVariadic", h.WithVariadic) {
			return
		}
	}
}

func (h *TestHandler) Serve(ctx context.Context, method string, stream rpc.Stream) error {
	switch method {
	case "WithContext":
		return h.WithContext(ctx, stream)
	case "WithError":
		return h.WithError(ctx, stream)
	case "WithNames":
		return h.WithNames(ctx, stream)
	case "WithNothing":
		return h.WithNothing(ctx, stream)
	case "WithParam":
		return h.WithParam(ctx, stream)
	case "WithResult":
		return h.WithResult(ctx, stream)
	case "WithStructParam":
		return h.WithStructParam(ctx, stream)
	case "WithStructResult":
		return h.WithStructResult(ctx, stream)
	case "WithVariadic":
		return h.WithVariadic(ctx, stream)
	default:
		return rpc.UnknownMethod(method)
	}
}
